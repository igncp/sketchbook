var d = diagrams.box.generateDefinition,
  c = diagrams.box.generateContainer,
  s = diagrams.shared.get;

diagrams.box({
  name: s('project') + ' test suite',
  body: [
    c('DragDropManager', [
      c('handler registration', [
        'registers and unregisters drag sources',
        'registers and unregisters drop targets',
        'registers and unregisters multi-type drop targets',
        'knows the difference between sources and targets',
        'accepts symbol types',
        'throws on invalid type',
        'calls setup() and teardown() on backend',
        'returns string handles',
        'accurately reports handler role',
      ]),
      c('drag source and target contract', [
        c('beginDrag() and canDrag()', [
          'ignores beginDrag() if canDrag() returns false',
          'throws if beginDrag() returns non-object',
          'begins drag if canDrag() returns true',
          'throws in beginDrag() if it is called twice during one operation',
          'throws in beginDrag() if it is called with an invalid handles',
          'calls beginDrag() on the innermost handler with canDrag() returning true',
          'lets beginDrag() be called again in a next operation',
        ]),
        c('drop(), canDrop() and endDrag()', [
          'endDrag() sees drop() return value as drop result if dropped on a target',
          'endDrag() sees {} as drop result by default if dropped on a target',
          'endDrag() sees null as drop result if dropped outside a target',
          'calls endDrag even if source was unregistered',
          'throws in endDrag() if it is called outside a drag operation',
          'ignores drop() if no drop targets entered',
          'ignores drop() if drop targets entered and left',
          'ignores drop() if canDrop() returns false',
          'ignores drop() if target has a different type',
          'throws in drop() if it is called outside a drag operation',
          'throws in drop() if it returns something that is neither undefined nor an object',
          'throws in drop() if called twice',
          c('nested drop targets', [
            'uses child result if parents have no drop result',
            'excludes targets of different type when dispatching drop',
            'excludes non-droppable targets when dispatching drop',
            'lets parent drop targets transform child results',
            'always chooses parent drop result',
            'excludes removed targets when dispatching drop',
          ]),
        ]),
        c('hover()', [
          'throws on hover after drop',
          'throws on hover outside dragging operation',
          'excludes targets of different type when dispatching hover',
          'includes non-droppable targets when dispatching hover',
          'throws in hover() if it contains the same target twice',
          'throws in hover() if it is called with a non-array',
          'throws in hover() if it contains an invalid drop target',
          'throws in hover() if it contains a removed drop target',
        ]),
      ]),
    ]),

    c('DragDropMonitor', [
      c('state change subscription', [
        'throws on bad listener',
        'throws on bad handlerIds',
        'allows to unsubscribe',
        'raises global change event on beginDrag()',
        'raises local change event on sources and targets in beginDrag()',
        'raises local change event on sources and targets in endDrag()',
        'raises local change event on sources and targets in drop()',
        'raises local change event only on previous and next targets in hover()',
        'raises local change event when target stops being or becomes innermost in hover()',
        'raises global change event on endDrag()',
        'raises global change event on drop()',
        'does not raise global change event if hover targets have not changed',
      ]),
      c('offset change subscription', [
        'throws on bad listener',
        'allows to unsubscribe',
        'throws when passing clientOffset without getSourceClientOffset',
        'sets source client offset from the innermost draggable source',
        'keeps track of offsets',
        'keeps track of offsets when initial offset is not specified',
        'keeps track of offsets when current offset is not specified',
        'raises offset change event on beginDrag()',
        'raises offset change event on hover() if clientOffset changed',
        'does not raise offset change event on hover() when not tracking offset',
        'does not raise offset change event on hover() when clientOffset has not changed',
        'raises offset change event on endDrag()',
        'raises offset change event on drop()',
      ]),
      c('state tracking', [
        'returns true from canDrag unless already dragging or drag source opts out',
        'returns true from canDrop if dragging and type matches, unless target opts out',
        'treats symbol types just like string types',
        'returns true from isDragging only while dragging',
        'keeps track of dragged item, type and source handle',
        'keeps track of drop result and whether it occured',
      ]),
      c('multi-type targets', [
        'takes all types into consideration',
        'returns false from isDragging(sourceId) if source is not published',
        'ignores publishDragSource() outside dragging operation',
      ]),
      c('target handle tracking', [
        'treats removing a hovered drop target as unhovering it',
        'keeps track of target handles',
        'resets target handles on drop',
        'resets target handles on endDrag',
        'counts non-droppable targets, but skips targets of another type',
        'correctly handles isOverTarget() for multi-type targets',
        'does not let array mutation corrupt internal state',
      ]),
      c('mirror drag sources', [
        'uses custom isDragging functions',
      ]),
    ]),
  ],
});
