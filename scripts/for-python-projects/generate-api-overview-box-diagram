#!/usr/bin/env python

import ast
import sys
import os
import unicodedata

import _common.utils as utils

project_path = os.path.abspath(sys.argv[1])
output_file_path = os.path.abspath(sys.argv[2])

files_dict = {}
files_doc_strings_dict = {}


def get_docstring(node):
  doc_string = ast.get_docstring(node)
  if doc_string:
    max_chars = 300
    doc_string = doc_string.replace('=', '').replace('\n', ' ').replace('\r', '').replace('"', '\'')
    if len(doc_string) > max_chars: doc_string = doc_string[0:max_chars] + '...'
    return doc_string
  else: return None


def add_item_to_files_dict(path, addition):
  if (path not in files_dict): files_dict[path] = []
  files_dict[path].append(addition)


def print_classes(path):
  f = open(path, 'r')
  content = f.read()
  f.close()
  parsed = ast.parse(content)
  relative_path = path.replace(project_path, '')
  class_definitions = [node for node in parsed.body if isinstance(node, ast.ClassDef)]
  ds = get_docstring(parsed)
  if ds: files_doc_strings_dict[relative_path] = ds
  function_definitions = [node for node in parsed.body if isinstance(node, ast.FunctionDef)]
  for class_definition in class_definitions:
    bases = [base.id for base in class_definition.bases if hasattr(base, 'id')]
    class_line = 'c("' + class_definition.name + '(' + ', '.join(bases) + ')", "'
    class_line += relative_path + '; '
    doc_string = get_docstring(class_definition)
    if doc_string: class_line += doc_string
    class_line += '", ['
    method_definitions = [node for node in class_definition.body
      if isinstance(node, ast.FunctionDef)]
    method_strs = []
    for method_definition in method_definitions:
      args = [arg.id for arg in method_definition.args.args]
      method_strs.append('d("' + method_definition.name + '(' + ', '.join(args) + ')' + '"),')
    class_line += '\n' + '\n'.join(sorted(method_strs)) + ']),'
    add_item_to_files_dict(relative_path, class_line)
  for function_definition in function_definitions:
    args = [arg.id for arg in function_definition.args.args]
    function_line = 'd("' + function_definition.name + '(' + ', '.join(args) + ')' + '"'
    doc_string = get_docstring(function_definition)
    if doc_string: function_line += ', "' + doc_string + '"'
    function_line += '),'
    add_item_to_files_dict(relative_path, function_line)


def setInDict(dataDict, mapList, value):
  def getFromDict(dataDict, mapList):
      return reduce(lambda d, k: d[k], mapList, dataDict)
  getFromDict(dataDict, mapList[:-1])[mapList[-1]] = value


def generate_nested_api():
  def fill_tree_dict(d, k):
    if k not in d: d[k] = {}
    return d[k]

  def update_tree_dict_with_path(path):
    path_steps = path[1:].split('/')
    reduce(fill_tree_dict, path_steps, tree_dict)
    setInDict(tree_dict, path_steps, ''.join(files_dict[path]))

  def generate_str_recursively(data, path):
    if isinstance(data, dict):
      data_keys = data.keys()

      def mykey(x):
        steps = x.split('/')
        last_step = steps[-1]
        return utils.is_python_file(last_step), x.upper()

      data_keys = sorted(data_keys, key=mykey)
      final_str = ''
      for data_key in data_keys:
        current_path = path + '/' + data_key
        ds = ''
        if current_path in files_doc_strings_dict: ds = ' ' + files_doc_strings_dict[current_path]
        final_str += '\nc("' + data_key + '", "' + current_path + ds + '", ['
        final_str += generate_str_recursively(data[data_key], current_path)
        final_str += ']),'
      return final_str
    elif isinstance(data, str) or isinstance(data, unicode):
      if isinstance(data, unicode):
        data = unicodedata.normalize('NFKD', data).encode('ascii', 'ignore')
      return '\n' + data

  tree_dict = {}
 
  files_dict_keys = sorted(files_dict.keys())
  for files_dict_key in files_dict_keys:
    update_tree_dict_with_path(files_dict_key)
  
  return generate_str_recursively(tree_dict, '')

utils.walk_dir_python_files(project_path, print_classes)

diagram_str = utils.add_box_diagram_beginning('generated api overview')
diagram_str += generate_nested_api()
diagram_str += "\n]});"

utils.set_file_content(output_file_path, diagram_str)
